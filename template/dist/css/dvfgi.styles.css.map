{"version":3,"sources":["abstractions/_visually-hidden.scss","../../node_modules/singularitygs/stylesheets/singularitygs/_css-grid.scss","abstractions/components/_test-singularity.scss","styles.css","base/_box-sizing.scss","components/atoms/_body.scss","variables/_colors.scss","variables/_typography.scss","components/atoms/_html.scss","components/atoms/_invisible.scss","components/test/_breakpoint.scss","components/test/_singularity.scss","../../node_modules/singularitygs/stylesheets/singularitygs/_api.scss","../../node_modules/singularitygs/stylesheets/singularitygs/math/_columns.scss","../../node_modules/singularitygs/stylesheets/singularitygs/api/_isolation.scss","../../node_modules/singularitygs/stylesheets/singularitygs/helpers/_directions.scss","components/test/_sprite.scss","abstractions/_sprite.scss","variables/_image-map.scss","variables/_sprites/_sprite-avatars.scss","../../node_modules/breakpoint-sass/stylesheets/_breakpoint.scss","abstractions/components/_test-breakpoint.scss","components/test/_mq-conbine.scss"],"names":[],"mappings":"AACA;EACE,mBAAkB;EAClB,UAAS;EACT,cAAa;EACb,iBAAgB;EAChB,UAAS;EACT,WAAU;EACV,WAAU;EACV,YAAW;CAcZ;;AAVE;EAGG,iBAAgB;EAChB,kBAAiB;EACjB,WAAU;EACV,YAAW;EACX,aAAY;CACb;;ACuCsB;EC5D3B;ID6DI,cAAa;IAKT,uCA9DoC;IA0EpC,iBAnD2B;IAsB7B,gBAAO;IACP,iBAAQ;GChDb;CC+BA;;ACjCD;EACE,+BAAsB;UAAtB,uBAAsB;CACvB;;ACFD;EACE,uBCQgB;EDPhB,eCAwB;EDCxB,yFEA8G;EFC9G,UAAS;CACV;;AGJD;EACE,gBAA2C;CAC5C;;ACFD;EACE,mBAAkB;CACnB;;ACHD;EAEE,YJOgB;CIEjB;;ACHD;ECyFI,iBCzEoD;EDyEpD,YAvCgF;EAuChF,oBEjDoD;EFiDpD,uBErCiG;EFqCjG,YEpB0C;CHnE7C;;AAED;ECqFI,cCzEoD;EDyEpD,aG5Fa;EH4Fb,eE5DgD;EF4DhD,uBEzD8E;EFyD9E,YEpB0C;CH/D7C;;AKdD;EC0DI,0CCoBqB;EDnBrB,aEfU;EFgBV,cEfW;CHvCV;;AANL;EAUQ,6BGMS;CHLV;;AAXP;EAUQ,gCGYS;CHXV;;AAXP;EAUQ,gCGkBY;CHjBb;;AAXP;EAUQ,mCGwBY;CHvBb;;AAXP;EAUQ,gCG8BS;CH7BV;;AIqDH;EChEJ;IAEI,YAAW;GAEd;ClBmBA;;AiByCG;EVhEJ;IAKI,YJGc;GIGjB;EYHD;IAMI,YhBNc;GgBQjB;CnB8CA;;AmB3DC;EADF;IAEI,ehBHqB;GgBKxB;EAED;IAEI,YhBFc;GgBQjB;CnB0DA;;AiBVG;EVhEJ;IASI,YJAc;GIEjB;CPyDA","file":"dvfgi.styles.css","sourcesContent":["// hidden from view but accessible to screen-readers\n%visually-hidden {\n  position: absolute;\n  top: auto;\n  left: -9999em;\n  overflow: hidden;\n  margin: 0;\n  padding: 0;\n  width: 1px;\n  height: 1px;\n\n  // The .focusable class extends the .visually-hidden class to allow\n  // the element to be focusable when navigated to via the keyboard.\n  &.focusable {\n    &:active,\n    &:focus {\n      position: static;\n      overflow: visible;\n      clip: auto;\n      width: auto;\n      height: auto;\n    }\n  }\n}\n","@import 'breakpoint';\n\n@function _css-gridtemplate-conversion($grid) {\n  @if type-of($grid) == 'number' or length($grid) == 1 {\n    @return unquote('repeat(#{$grid}, 1fr)');\n  }\n  @else if type-of($grid) == 'list' or length($grid) > 1 {\n    $holder: '';\n    @each $column in $grid {\n      @if unitless($column) {\n        $holder: $holder + '#{$column}fr ';\n      }\n      @else {\n        $holder: $holder + $column + ' ';\n      }\n    }\n\n    $holder: str-slice($holder, 0, str-length($holder) - 1);\n\n    @return unquote($holder);\n  }\n\n  @return $grid;\n}\n\n@function _css-grid-gap-conversion($gutter) {\n  @if unitless(nth($gutter, 1)) {\n    @return unquote('#{$gutter}fr');\n  }\n\n  @return $gutter;\n}\n\n@mixin _css-grid-container-padding-conversation($style) {\n  @if length($style) == 1 {\n    $style: nth($style, 1);\n  }\n\n  @if str-index($style, 'split') != null {\n    $gutter: find-gutter() / 2;\n    $padding: _css-grid-gap-conversion($gutter);\n\n    padding: {\n      left: $padding;\n      right: $padding;\n    }\n  }\n  @else {\n    padding: {\n      left: 0;\n      right: 0;\n    }\n  }\n}\n\n@mixin grid-container() {\n  $grids: sgs-get('grids');\n  $gutters: sgs-get('gutters');\n  $gutter-styles: sgs-get('gutter styles');\n\n  @supports (display: grid) {\n    display: grid;\n\n    // Build Column Templates\n    @each $mq, $grid in $grids {\n      @if $mq == -1px {\n        grid-template-columns: _css-gridtemplate-conversion($grid);\n      }\n      @else {\n        @include mq($mq) {\n          grid-template-columns: _css-gridtemplate-conversion($grid);\n        }\n      }\n    }\n\n    // Build Gaps\n    @each $mq, $gutter in $gutters {\n      @if $mq == -1px {\n        grid-gap: _css-grid-gap-conversion($gutter);\n      }\n      @else {\n        @include mq($mq) {\n          grid-gap: _css-grid-gap-conversion($gutter);\n        }\n      }\n    }\n\n    // Build Padding\n    @each $mq, $style in $gutter-styles {\n      @if $mq == -1px {\n        @include _css-grid-container-padding-conversation($style);\n      }\n      @else {\n        @include mq($mq) {\n          @include _css-grid-container-padding-conversation($style);\n        }\n      }\n    }\n  }\n}\n\n@mixin css-grid-span($Span, $Location: false) {\n  $grid: find-grid();\n\n  @if type-of($grid) == 'number' or length($grid) == 1 {\n    // If we have a symmetric grid _and_ no location, Float Span makes most sense\n    @if $Location == false {\n      @include float-span($Span, $Location);\n    }\n    // If we have an symmetric grid _and_ a location, Isolation Span makes most sense\n    @else {\n      @include isolation-span($Span, $Location);\n    }\n  }\n  @else if type-of($grid) == 'list' or length($grid) > 1 {\n    $calc: false;\n    @each $column in $grid {\n      @if not unitless($column) {\n        $calc: true;\n      }\n    }\n\n    // If we have an asymmetric grid _and_ it includes united numbers, needs to be Calc\n    @if ($calc) {\n      @include calc-span($Span, $Location);\n    }\n    // If we have an asymmetric grid _and_ it doesn't include united numbers, Islotion's better\n    @else {\n      @include isolation-span($Span, $Location);\n    }\n  }\n\n  @supports (display: grid) {\n    @if $Location {\n      grid-columns: $Location / span $Span;\n    }\n    @else {\n      grid-columns: span $Span;\n    }\n  }\n}","%grid-container {\n  @include grid-container;\n}\n",".visually-hidden {\n  position: absolute;\n  top: auto;\n  left: -9999em;\n  overflow: hidden;\n  margin: 0;\n  padding: 0;\n  width: 1px;\n  height: 1px;\n}\n\n.focusable.visually-hidden:active, .focusable.visually-hidden:focus {\n  position: static;\n  overflow: visible;\n  clip: auto;\n  width: auto;\n  height: auto;\n}\n\n@media (min-width: 300px) {\n  .bp-foo {\n    width: 100%;\n  }\n}\n\n@supports (display: grid) {\n  .sg-container {\n    display: grid;\n    grid-template-columns: repeat(12, 1fr);\n    grid-gap: 0.25fr;\n    padding-left: 0;\n    padding-right: 0;\n  }\n}\n\n* {\n  box-sizing: border-box;\n}\n\nbody {\n  background-color: #fff;\n  color: #252525;\n  font-family: \"OpenSans\", \"HelveticaNeue\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 0;\n}\n\nhtml {\n  font-size: 100%;\n}\n\n.invisible {\n  visibility: hidden;\n}\n\n.bp-foo {\n  color: #fff;\n}\n\n@media (min-width: 600px) {\n  .bp-foo {\n    color: #000;\n  }\n}\n\n@media (min-width: 800px) {\n  .bp-foo {\n    color: #fff;\n  }\n}\n\n@media screen and (min-width: 600px) {\n  .mq-foo {\n    color: #8f211f;\n  }\n}\n\n@media screen and (min-width: 600px) {\n  .mq-bar {\n    color: #000;\n  }\n}\n\n@media (min-width: 600px) {\n  .mq-bar {\n    color: #000;\n  }\n}\n\n.sg-foo {\n  width: 64.58333%;\n  float: left;\n  margin-right: -100%;\n  margin-left: -7.29167%;\n  clear: none;\n}\n\n.sg-bar {\n  width: 31.25%;\n  float: right;\n  margin-left: 0;\n  margin-right: 1.04167%;\n  clear: none;\n}\n\n.sprite-test .avatar::after {\n  background: url(\"../images/avatars.png\") ;\n  width: 384px;\n  height: 256px;\n}\n\n.sprite-test .avatar.avatar--128-1 {\n  background-position: 0px 0px;\n}\n\n.sprite-test .avatar.avatar--128-2 {\n  background-position: -128px 0px;\n}\n\n.sprite-test .avatar.avatar--128-3 {\n  background-position: 0px -128px;\n}\n\n.sprite-test .avatar.avatar--128-4 {\n  background-position: -128px -128px;\n}\n\n.sprite-test .avatar.avatar--128-5 {\n  background-position: -256px 0px;\n}\n","* {\n  box-sizing: border-box;\n}\n","body {\n  background-color: $color-body;\n  color: $color-copy;\n  font-family: $font-family-default;\n  margin: 0;\n}\n","// Primary palette\n$color-old-brick: #8f211f;\n$color-mine-shaft: #252525;\n\n// Secondary palette\n$color-silver: #c7c7c7;\n\n// Gray palette\n$color-black: #000;\n$color-white: #fff;\n\n// use-cases\n$color-main: $color-old-brick;\n\n// - typo\n$color-copy: $color-mine-shaft;\n$color-copy-inactive: $color-silver;\n$color-copy-inverted: $color-white;\n$color-link: $color-main;\n\n// - body\n$color-body: $color-white;\n\n// - borders\n$color-border-default: $color-silver;\n\n// - misc\n$color-shadow: $color-black;\n","$font-path: '../../fonts/';\n\n$font-family-name-default: 'OpenSans';\n$font-family-default: $font-family-name-default, 'HelveticaNeue', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n\n$font-size-huge: 34px;\n$font-size-large: 24px;\n$font-size-default: 16px;\n$font-size-minor: 14px;\n$font-size-small: 12px;\n","// Set the base font-size, but keep an option for the user to adjust it to their needs.\nhtml {\n  font-size: $font-size-default / 16px * 100%;\n}\n","// Hide visually and from screen readers, but maintain layout.\n.invisible {\n  visibility: hidden;\n}\n",".bp-foo {\n  @extend %bp-foo;\n  color: $color-white;\n\n  @include breakpoint(600px)  {\n    color: $color-black;\n  }\n\n  @include breakpoint(800px)  {\n    color: $color-white;\n  }\n}\n","@include add-grid(12);\n@include add-gutter(1/3);\n@include add-gutter-style('split');\n\n.sg-container {\n  @extend %grid-container;\n}\n\n.sg-foo {\n  @include grid-span(8, 0);\n}\n\n.sg-bar {\n  @include grid-span(4, 9);\n}\n","@import \"api/float\";\n@import \"api/isolation\";\n@import \"api/calc\";\n\n//////////////////////////////\n// Master Grid Span mixin\n//////////////////////////////\n@mixin grid-span($span, $location: 1, $grid: null, $gutter: null, $output-style: null, $gutter-style: null, $options: null) {\n\n  @if $output-style == null {\n    $output-style: sgs-get('output');\n  }\n\n  $Grid: find-grid($grid);\n  $Gutter: find-gutter($gutter);\n  $Style: find-gutter-style($gutter-style);\n\n  $Start-Row: start-row($location);\n  $End-Row: end-row($span, $location, $Grid);\n\n  $Fixed-Gutter: fixed-gutter($Grid, $Gutter, $Style);\n  $Split-Gutter: index($Style, 'split');\n  $Gutter-Property: gutter-property($Grid, $Gutter, $Style);\n\n  $Direction: sgs-get('direction');\n  $From: if($options and type-of($options) == 'map', if(map-get($options, 'from'), map-get($options, 'from'), $Direction), $Direction);\n  $From: if($From == 'ltr' or $From == 'rtl', named-direction($From), $From);\n\n  $Holder: ();\n  @each $k, $v in $options {\n    $Holder: if($k == 'from', $Holder, map-merge($Holder, ($k: $v)));\n  }\n  $options: if(length($Holder) > 0, $Holder, null);\n\n  $Span-Map: (\n    'span': $span,\n    'location': $location,\n    'grid': $Grid,\n    'gutter': $Gutter,\n    'style': $Style,\n    'start row': $Start-Row,\n    'end row': $End-Row,\n    'fixed gutter': $Fixed-Gutter,\n    'split gutter': $Split-Gutter,\n    'gutter property': $Gutter-Property,\n    'options': $options\n  );\n\n  @if sgs-get('debug') != false {\n    -sgs-span-settings: inspect($Span-Map);\n  }\n\n\n  @if function-exists('output-#{$output-style}') {\n    $Left: ();\n    $Right: ();\n\n    @if $Direction == 'both' or $From == 'left' or ($Direction == 'rtl' and $From == 'opposite') {\n      $Left: call('output-#{$output-style}', map-merge($Span-Map, ('direction': left)));\n    }\n\n    @if $Direction == 'both' or $From == 'right' or ($Direction == 'ltr' and $From == 'opposite') {\n      $Right: call('output-#{$output-style}', map-merge($Span-Map, ('direction': right)));\n    }\n\n    $Left-Keys: map-keys($Left);\n    $Right-Keys: map-keys($Right);\n    $Exclude: ();\n\n    @each $key in $Left-Keys {\n      @if index($Right-Keys, $key) {\n        @if map-get($Right, $key) == map-get($Left, $key) {\n          $Exclude: append($Exclude, $key);\n        }\n      }\n    }\n\n    // Always try and print the Left value\n    @include grid-span-build-exclude($Left, $Exclude, false);\n\n    // If Direction is Both or RTL, add the RTL attribute selector\n    @if $Direction == 'both' or $Direction == 'rtl' {\n      [dir=\"rtl\"] & {\n        @include grid-span-build-exclude($Right, $Exclude, true);\n      }\n    }\n    @else {\n      @include grid-span-build-exclude($Right, $Exclude, true);\n    }\n  }\n  @else {\n    @warn \"There doesn't appear to be an output style named `#{$output-style}`. Please ensure that the function `output-#{$output-style}` and that the output style `#{$output-style}` are both available before trying to use them.\";\n  }\n}\n\n@mixin grid-span-build($property, $value) {\n  @if type-of($value) != 'map' {\n    #{$property}: $value;\n  }\n  @else {\n    @each $prefix, $val in $value {\n      #{$property}: $val;\n    }\n  }\n}\n\n@mixin grid-span-build-exclude($properties, $delta, $exclude: false) {\n  @each $property, $value in $properties {\n    @if $exclude {\n      @if not index($delta, $property) {\n        @include grid-span-build($property, $value);\n      }\n    }\n    @else {\n      @include grid-span-build($property, $value);\n    }\n  }\n}","//////////////////////////////\n// Find width, in percentages, of the column span\n//////////////////////////////\n@function column-span($span, $location, $grid: null, $gutter: null, $gutter-style: null) {\n  // Find the grid and gutters\n  $grid: find-grid($grid);\n  $gutter: find-gutter($gutter);\n  $gutter-style: find-gutter-style($gutter-style);\n\n  @if fixed-gutter($grid, $gutter, $gutter-style) {\n    $gutter: 0;\n  }\n\n  // @debug $grid;\n  // @debug $gutter;\n\n  // Combine the grid and gutters\n  $grid-and-gutters: column-sum($grid, $gutter, $gutter-style);\n\n  // @debug $grid-and-gutters;\n\n  // Equal width grid are easy! Deal with them!\n  @if type-of($grid) == 'number' or length($grid) == 1 {\n    $span-and-gutters: $span + $gutter * ($span - 1);\n    @return $span-and-gutters / $grid-and-gutters * 100%;\n  }\n  // Asymmetric lists are harder, so we're going to treat them as their own grid\n  @else if type-of($grid) == 'list' or length($grid) > 1 {\n    $span-and-gutters: 0;\n\n    @if $location == 1 and $span >= 1 {\n      @for $i from 1 through $span {\n        $span-and-gutters: $span-and-gutters + nth($grid, $i) + $gutter;\n      }\n    }\n    @else {\n      $total: $location + $span - 1;\n      @if $total != 0 {\n        @for $i from $location through $total {\n          $span-and-gutters: $span-and-gutters + nth($grid, $i) + $gutter;\n        }\n      }\n    }\n    $span-and-gutters: $span-and-gutters - $gutter;\n\n    @return $span-and-gutters / $grid-and-gutters * 100%;\n  }\n  @else {\n    @warn \"Can't find a working set of grid! That's terrible!\";\n    @return false;\n  }\n}\n\n//////////////////////////////\n// Find the total sum of the grid\n//////////////////////////////\n@function column-sum($grid, $gutter, $gutter-style) {\n  $split: if(index($gutter-style, 'split'), true, false);\n\n  @if type-of($grid) == 'number' or length($grid) == 1 {\n    @if $split {\n      @return nth($grid, 1) + ((column-count(nth($grid, 1))) * nth($gutter, 1));\n    }\n    @else {\n      @return nth($grid, 1) + ((column-count(nth($grid, 1)) - 1) * nth($gutter, 1));\n    }\n\n  }\n  @else if type-of($grid) == 'list' {\n    $sum: 0;\n    @each $column in $grid {\n      $sum: $sum + nth($column, 1);\n    }\n    @if $split {\n      $sum: $sum + (column-count($grid)) * nth($gutter, 1);\n    }\n    @else {\n      $sum: $sum + (column-count($grid) - 1) * nth($gutter, 1);\n    }\n    @return $sum;\n  }\n}\n\n//////////////////////////////\n// Find the number of grid\n//////////////////////////////\n@function column-count($grid) {\n  @if type-of($grid) == 'number' {\n    @return $grid;\n  }\n  @if type-of($grid) == 'list' {\n    @if length($grid) == 1 {\n      @return nth($grid, 1);\n    }\n    @else {\n      @return length($grid);\n    }\n  }\n}","@function output-isolation($Span-Map) {\n  // Set up Left/Right maps\n  $Return: ();\n\n  $Span: map-get($Span-Map, 'span');\n  $Location: map-get($Span-Map, 'location');\n\n  $Grid: map-get($Span-Map, 'grid');\n  $Gutter: map-get($Span-Map, 'gutter');\n  $Style: map-get($Span-Map, 'style');\n\n  $Start-Row: map-get($Span-Map, 'start row');\n  $End-Row: map-get($Span-Map, 'end row');\n\n  $Fixed-Gutter: map-get($Span-Map, 'fixed gutter');\n  $Split-Gutter: map-get($Span-Map, 'split gutter');\n  $Gutter-Property: map-get($Span-Map, 'gutter property');\n\n  $Direction: map-get($Span-Map, 'direction');\n  $Options: map-get($Span-Map, 'options');\n\n  $Width: column-span($Span, $Location, $Grid, $Gutter, $Style);\n  $Margin-Span: column-span(($Location - 1), 1, $Grid, $Gutter, $Style);\n  $Gutter-Span: gutter-span($Gutter, $Grid);\n\n  // Backwards Compatibility for Options\n  @if type-of($Options) != 'map' and $Options != null {\n    $Options: ('clear': unquote(nth($Options, 1)));\n  }\n\n  $Dir: $Direction;\n  $Opp: opposite-direction($Dir);\n\n  $Return: map-merge($Return, ('width': $Width));\n\n  @if ($End-Row) {\n    $Return: map-merge($Return, ('float': $Opp));\n    $Return: map-merge($Return, ('margin-#{$Dir}': 0));\n\n    @if $Split-Gutter and not $Fixed-Gutter {\n      $Return: map-merge($Return, ('#{$Gutter-Property}-#{$Opp}': $Gutter-Span / 2));\n    }\n    @else {\n      $Return: map-merge($Return, ('margin-#{$Opp}': 0));\n    }\n  }\n  @else {\n    $Return: map-merge($Return, ('float': $Dir));\n    $Return: map-merge($Return, ('margin-#{$Opp}': -100%));\n\n    @if $Start-Row {\n      @if $Split-Gutter and not $Fixed-Gutter {\n        $Return: map-merge($Return, ('margin-#{$Dir}': $Gutter-Span / 2));\n      }\n      @else if not $Fixed-Gutter {\n        $Return: map-merge($Return, ('margin-#{$Dir}': 0));\n      }\n    }\n    @else {\n      @if $Split-Gutter and not $Fixed-Gutter {\n        $Return: map-merge($Return, ('margin-#{$Dir}': $Margin-Span + $Gutter-Span + $Gutter-Span / 2));\n      }\n      @else if not $Fixed-Gutter {\n        $Return: map-merge($Return, ('margin-#{$Dir}': $Margin-Span + $Gutter-Span));\n      }\n      @else {\n        $Return: map-merge($Return, ('margin-#{$Dir}': $Margin-Span));\n      }\n    }\n  }\n  // If options are set, we merge them in!\n  @if ($Options) {\n    $Return: map-merge($Return, $Options);\n  }\n\n  // If CLear isn't already available, set it!\n  @if not map-has-key($Return, 'clear') {\n    $Return: map-merge($Return, ('clear': none));\n  }\n\n  // Left Fixed Gutters\n  @if $Fixed-Gutter {\n    @if index($Style, 'split') {\n      $Return: map-merge($Return, ('#{$Gutter-Property}-#{$Dir}': $Gutter-Span / 2));\n      $Return: map-merge($Return, ('#{$Gutter-Property}-#{$Opp}': $Gutter-Span / 2));\n    }\n    @else {\n      @if not $End-Row {\n        $Return: map-merge($Return, ('#{$Gutter-Property}-#{$Opp}': $Gutter-Span));\n      }\n      @else {\n        $Return: map-merge($Return, ('#{$Gutter-Property}-#{$Opp}': 0));\n      }\n    }\n  }\n\n  @return $Return;\n}\n\n//////////////////////////////\n// Happy Syntax for Isolation\n//\n// Makes working with Isolation easier, as it moves Clear to a 1st class citizen of the mixin, and automatically builds the verbose grid-span mixin call\n//////////////////////////////\n@mixin isolation-span($Span, $Location, $clear: false, $grid: false, $gutter: false, $gutter-style: false, $from: false) {\n  $Options: ();\n  @if $clear {\n    $Options: map-merge($Options, ('clear': unquote($clear)));\n  }\n  @if $from {\n    $Options: map-merge($Options, ('from': $from));\n  }\n\n  $Options: if(length($Options) > 0, $Options, null);\n  @include grid-span($Span, $Location, $grid, $gutter, 'isolation', $gutter-style, $Options);\n}\n\n//////////////////////////////\n// Happy Syntax of Asymmetric Grids\n//\n// Makes working with asymmetric grids easier!\n//////////////////////////////\n@mixin asymmetric-span($Location, $Span: false, $grid: false, $gutter: false, $gutter-style: false, $from: false, $output-style: false) {\n\n  $Span: if($Span != false, $Span, 1);\n  $output-style: if($output-style != false, $output-style, sgs-get('asymmetric output'));\n\n  $Options: ();\n  @if $from {\n    $Options: map-merge($Options, ('from': $from));\n  }\n  $Options: if(length($Options) > 0, $Options, null);\n\n  @include grid-span($Span, $Location, $grid, $gutter, $output-style, $gutter-style, $Options);\n}","//////////////////////////////\n// Find Opposite Direction\n//////////////////////////////\n@function opposite-direction($dir) {\n  @if $dir == 'left' {\n    @return right;\n  }\n  @else if  $dir == 'right' {\n    @return left;\n  }\n  @else if $dir == 'ltr' {\n    @return rtl;\n  }\n  @else if $dir == 'rtl' {\n    @return ltr;\n  }\n  @else if $dir == 'top' {\n    @return bottom;\n  }\n  @else if $dir == 'bottom' {\n    @return top;\n  }\n  @else {\n    @warn \"#{$dir} is not a direction! Make sure your direction is all lowercase!\";\n    @return false;\n  }\n}\n\n//////////////////////////////\n// Find Direction Name\n//////////////////////////////\n@function named-direction($dir) {\n  @if $dir == 'ltr' {\n    @return left;\n  }\n  @else if $dir == 'rtl' {\n    @return right;\n  }\n  @else {\n    @warn \"#{$dir} is not a valid HTML direction! Make sure you are using a valid HTML direction\";\n    @return false;\n  }\n}",".sprite-test {\n  $sheet: $sp-avatars;\n\n  .avatar {\n    &::after {\n      @include sprite($sheet);\n    }\n\n    @each $avatar, $data in map-get($sheet, 'sprites') {\n      &.avatar--#{$avatar} {\n        background-position: sprite-offset($data);\n      }\n    }\n  }\n}\n","@function get-all-sprites($sheet) {\n  @return map-get($sheet, 'sprites');\n}\n\n@function get-first-sprite($sheet) {\n  @return nth(map-keys(get-all-sprites($sheet)), 1);\n}\n\n@function get-sprite($sheet, $sprite-name) {\n  @return map-get(get-all-sprites($sheet), $sprite-name);\n}\n\n@function sprite-image($sheet) {\n  @return map-get($sheet, 'image');\n}\n\n@function sprite-width($sprite) {\n  @return map-get($sprite, 'width');\n}\n\n@function sprite-height($sprite) {\n  @return map-get($sprite, 'height');\n}\n\n@function sprite-offset($sprite) {\n  @return map-get($sprite, 'offset-x') map-get($sprite, 'offset-y');\n}\n\n@function sheet-image($sheet) {\n  $img: map-get($sheet, 'image');\n\n  @if (function-exists('image-url')) {\n    @return image-url($img);\n  } @else {\n    @return url($img);\n  }\n}\n\n@mixin sprite-size($sheet, $sprite-name) {\n  $sprite: get-sprite($sheet, $sprite-name);\n\n  width: sprite-width($sprite);\n  height: sprite-height($sprite);\n}\n\n@mixin sprite($sheet, $sprite-name: false) {\n  $sprite: false;\n  @if (not $sprite-name) {\n    $sprite-name: get-first-sprite($sheet);\n  }\n\n  @if type-of($sheet) == 'map' {\n    $sprite: $sheet;\n  } @else {\n    $sprite: get-sprite($sheet, $sprite-name);\n  }\n\n  @if $sprite {\n    background: sheet-image($sheet) sprite-offset($sprite);\n    width: sprite-width($sprite);\n    height: sprite-height($sprite);\n  } @else {\n    @warn 'No sprite found!';\n  }\n}\n","// ============================================================================\n// DO NOT EDIT!\n//\n// This file is dynamically generated by gulp-compass-imagehelper and\n// polyfills the compass imagehelper functions to node-sass enviroments.\n// https://www.npmjs.com/package/gulp-compass-imagehelper\n// ============================================================================\n\n$compass-imagehelper-imagesmap:(\n  'amazon-payments.png': 512 366 9fdd15e2e31aad22ec55c6df826491db,\n  'avatars.png': 384 256 b850afc3a0ae70bdc9f79ca3364b3f12,\n  'icons.png': 1536 732 8f8c3a9dad4e64f131c07e41540c51a5,\n  'logo.svg': 94 16 3e22f62cdca116c4d2931ce8c02eb271,\n  'footer/footer-back.jpg': 25 25 2d70747032e0e554c4e1afc7bfe1897f,\n);\n\n\n@function compassImagehelper_getList($image) {\n  @if map-has-key($compass-imagehelper-imagesmap, $image) {\n    $list: map-get($compass-imagehelper-imagesmap, $image);\n    @if type-of($list) == 'list' {\n      @return $list;\n    }\n  }\n  @warn 'Image `#{$image}` not found.';\n  @return false;\n}\n\n\n// Returns the width of the image found at the path supplied by $image relative to your project's images directory.\n@function image-width($image) {\n  $list: compassImagehelper_getList($image);\n  $width: nth($list, 1);\n\n  @return $width * 1px;\n}\n\n\n// Returns the height of the image found at the path supplied by $image relative to your project's images directory.\n@function image-height($image) {\n  $list: compassImagehelper_getList($image);\n  $height: nth($list, 2);\n\n  @return $height * 1px;\n}\n\n\n// Returns if the image is accessible for these image-helpers\n// Note: Not part of the official compass functions, but still useful\n@function image-exists($image) {\n  @return map-has-key($compass-imagehelper-imagesmap, $image);\n}\n\n\n// Generates a path to an asset found relative to the project's images directory.\n// Passing a true value as the second argument will cause only the path to be returned instead of a url() function\n// The third argument is used to control the cache buster on a per-use basis. When set to false no cache buster will be used.\n// When true a md5-hash of the file is appended to the url. When a string, that value will be used as the cache buster.\n@function image-url($image, $only-path: false, $cache-buster: false) {\n  $result: '../images/' + $image;\n\n  @if ($cache-buster == true) {\n    @if not (image-exists($image)) {\n      @warn 'Image `#{$image}` not found. Cache-busting failed';\n    } @else if (map-has-key($compass-imagehelper-imagesmap, $image)) {\n      $list: map-get($compass-imagehelper-imagesmap, $image);\n      $hash: nth($list, 4);\n      $result: $result + '?' + $hash;\n    }\n  } @else if ($cache-buster == false) {\n  } @else {\n    // probably a string\n    $result: $result + '?' + $cache-buster;\n  }\n\n  $result: quote($result);\n\n  @if ($only-path == false) {\n    $result: url($result);\n  }\n\n  @return $result;\n}","// SCSS variables are information about icon's compiled state, stored under its original file name\n//\n// .icon-home {\n//   width: $icon-home-width;\n// }\n//\n// The large array-like variables contain all information about a single icon\n// $icon-home: x y offset_x offset_y width height total_width total_height image_path;\n//\n// At the bottom of this section, we provide information about the spritesheet itself\n// $spritesheet: width height image $spritesheet-sprites;\n$sp-avatars-sprites: (\n  '128-1': (\n    width: 128px,\n    height: 128px,\n    offset-x: 0px,\n    offset-y: 0px\n  ),\n  '128-2': (\n    width: 128px,\n    height: 128px,\n    offset-x: -128px,\n    offset-y: 0px\n  ),\n  '128-3': (\n    width: 128px,\n    height: 128px,\n    offset-x: 0px,\n    offset-y: -128px\n  ),\n  '128-4': (\n    width: 128px,\n    height: 128px,\n    offset-x: -128px,\n    offset-y: -128px\n  ),\n  '128-5': (\n    width: 128px,\n    height: 128px,\n    offset-x: -256px,\n    offset-y: 0px\n  ),\n);\n$sp-avatars: (\n  width: 384px,\n  height: 256px,\n  image: 'avatars.png',\n  sprites: $sp-avatars-sprites\n);\n\n\n","//////////////////////////////\n// Default Variables\n//////////////////////////////\n$Breakpoint-Settings: (\n  'default media': all,\n  'default feature': min-width,\n  'default pair': width,\n\n  'force all media type': false,\n  'to ems': false,\n  'transform resolutions': true,\n\n  'no queries': false,\n  'no query fallbacks': false,\n\n  'base font size': 16px,\n\n  'legacy syntax': false\n);\n\n$breakpoint: () !default;\n\n//////////////////////////////\n// Imports\n//////////////////////////////\n@import \"breakpoint/settings\";\n@import 'breakpoint/context';\n@import 'breakpoint/helpers';\n@import 'breakpoint/parsers';\n@import 'breakpoint/no-query';\n\n@import 'breakpoint/respond-to';\n\n@import \"breakpoint/legacy-settings\";\n\n//////////////////////////////\n// Breakpoint Mixin\n//////////////////////////////\n\n@mixin breakpoint($query, $no-query: false) {\n  @include legacy-settings-warning;\n\n  // Reset contexts\n  @include private-breakpoint-reset-contexts();\n\n  $breakpoint: breakpoint($query, false);\n\n  $query-string: map-get($breakpoint, 'query');\n  $query-fallback: map-get($breakpoint, 'fallback');\n\n  $private-breakpoint-context-holder: map-get($breakpoint, 'context holder') !global;\n  $private-breakpoint-query-count: map-get($breakpoint, 'query count') !global;\n\n  // Allow for an as-needed override or usage of no query fallback.\n  @if $no-query != false {\n    $query-fallback: $no-query;\n  }\n\n  @if $query-fallback != false {\n    $context-setter: private-breakpoint-set-context('no-query', $query-fallback);\n  }\n\n  // Print Out Query String\n  @if not breakpoint-get('no queries') {\n    @media #{$query-string} {\n      @content;\n    }\n  }\n\n  @if breakpoint-get('no query fallbacks') != false or breakpoint-get('no queries') == true {\n\n    $type: type-of(breakpoint-get('no query fallbacks'));\n    $print: false;\n\n    @if ($type == 'bool') {\n      $print: true;\n    }\n    @else if ($type == 'string') {\n      @if $query-fallback == breakpoint-get('no query fallbacks') {\n        $print: true;\n      }\n    }\n    @else if ($type == 'list') {\n      @each $wrapper in breakpoint-get('no query fallbacks') {\n        @if $query-fallback == $wrapper {\n          $print: true;\n        }\n      }\n    }\n\n    // Write Fallback\n    @if ($query-fallback != false) and ($print == true) {\n      $type-fallback: type-of($query-fallback);\n\n      @if ($type-fallback != 'bool') {\n        #{$query-fallback} & {\n          @content;\n        }\n      }\n      @else {\n        @content;\n      }\n    }\n  }\n\n  @include private-breakpoint-reset-contexts();\n}\n\n\n@mixin mq($query, $no-query: false) {\n  @include breakpoint($query, $no-query) {\n    @content;\n  }\n}\n","%bp-foo {\n  @include breakpoint(300px) {\n    width: 100%;\n  }\n}\n","$break: 600px;\n\n.mq-foo {\n  @media screen and (min-width: $break) {\n    color: $color-main;\n  }\n}\n\n.mq-bar {\n  @media screen and (min-width: $break) {\n    color: $color-black;\n  }\n\n  @media (min-width: $break) {\n    color: $color-black;\n  }\n}\n"]}